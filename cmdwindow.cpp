#include "cmdwindow.h"
#include "gshared.h"
#include "ui_cmdwindow.h"
#include <QDebug>
#include <QTextLayout>
#include <QTextCursor>
#include <QTextBlock>
#include <QComboBox>
#include <QTextCodec>
#include <string>
#include <QString>
#include <QThread>

#include "thread_execute_exp.h"




CMDWindow::CMDWindow(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::CMDWindow)
{
    ui->setupUi(this);

    timer = new QTimer(this);
    connect(timer, SIGNAL(timeout()), this, SLOT(on_timeout()));



    // 设置字体
    GShared::ubuntu_font.setPointSize(12);
    _my_text_edit.setFont(GShared::ubuntu_font);
    
    // 将自定义的编辑框加入到页面中
    ui->verticalLayout->addWidget(&_my_text_edit);

    // 启动一个本地cmd，用于执行命令
    //_cmd_process.start("cmd.exe");
    //putty [-pw password] [-m file] user@ip_addr
    /* -pw peter@Sec.com1314 root@149.129.47.247*/
    connect_signal_and_slot();
    _cmd_process.start("C:\\putty.exe -pw peter@Sec.com1314 root@149.129.47.247");
    _cmd_process.waitForStarted();

    // 将内部的工具箱设置为终端的临时环境变量
    char path[160] = "set path=%path%;";
    strcat(path, GShared::program_tools.toStdString().c_str());
    strcat(path, "\n");
    //_cmd_process.write("ssh://root:peter@Sec.com1314@149.129.47.247");
    // 连接信号与槽
    _cmd_process.write("nc\n");

}

CMDWindow::~CMDWindow()
{
    delete ui;
}

void CMDWindow::check()
{
    /*
        得到当前光标所在位置
    */
    QTextCursor text_cursor = _my_text_edit.textCursor();
    // 当前光标的列坐标
    int column_idx = text_cursor.position() - text_cursor.block().position();
    QTextLayout* p_text_layout = text_cursor.block().layout();
    // 当前光标的行坐标
    int line_idx = p_text_layout->lineForTextPosition(column_idx).lineNumber() + text_cursor.block().firstLineNumber();

    /**
        1. 判断行。
            如果光标所在行小于输入行。 肯定不允许输入
            如果光标所在行小于输入行。 肯定允许输入
            光标所在行等于输入行，判断列
        2. 判断列。
            如果光标所在列小于输入列。 肯定不允许输入
            如果光标所在列小于输入列。 肯定允许输入
        3. 光标所在行和列 和 输入行列相等。(初始状态，没任何输入的情况)
            接受输入，但是不接受 退格键。
      */
    if (line_idx < _cursor_line)
        //当前行在输入行上面，肯定不能输入
    {
        _my_text_edit._is_accept_key_input = false;
        _my_text_edit._isEnable_BK = false;
    }
    else if (line_idx > _cursor_line)
    {
        //光标所在行小于输入行。 肯定允许输入
        _my_text_edit._is_accept_key_input = true;
        _my_text_edit._isEnable_BK = true;
    }
    else
        // 在同一行的情况下，再进行判断
    {
        if (column_idx < _cursor_column)
            //光标所在列小于输入列。 肯定不允许输入
        {
            _my_text_edit._is_accept_key_input = false;
            _my_text_edit._isEnable_BK = false;
        }
        else if (column_idx > _cursor_column)
            //光标所在列小于输入列。 肯定允许输入
        {
            _my_text_edit._is_accept_key_input = true;
            _my_text_edit._isEnable_BK = true;
        }
        else
        {
            //光标所在行和列 和 输入行列相等。接受输入，但是不接受 退格键。
            _my_text_edit._is_accept_key_input = true;
            _my_text_edit._isEnable_BK = false;
        }
    }
}
/**
 * @brief 当编辑框的光标位置发生改变时，调用这个槽函数。
 * 主要是为了判断当前位置能不能接受输入，以及能不能接受退格键
 */
void CMDWindow::on_cursorPositionChanged()
{
    check();
}

void CMDWindow::on_cmd_process_readoutput()
{
    if (_running_process_id == 1 && _run_time > 0)
    {
        QTextCodec *GBK = QTextCodec::codecForName("GBK");
        QString str;
        str = GBK->toUnicode(_cmd_process.readAllStandardOutput().data());
        return;
    }
    // 将终端传来的字符串用[UTF8]进行编码
    // 并且在windows上删除 "\r"。linux上未定义。
    QTextCodec *GBK = QTextCodec::codecForName("GBK");
    QString str;
    str = GBK->toUnicode(_cmd_process.readAllStandardOutput().data());
    if(str == "")
        return;
    str = str.replace("\r", "");

    /*
        输入完一个命令后，控制台回显的内容一般是如下格式：
        \n命令本身\n真正的内容
        所以要针对进行一些更改，使之看起来和真的控制台的格式一样。
    */
    // 删除第一个'\n'。
    if (str.startsWith("\n"))
    {
        str = str.remove(0, 1);
    }

    // 删除开始的回显命令
    if (_last_cammand != "" && str.startsWith(_last_cammand))
    {
       str = str.remove(0, _last_cammand.length());
    }

    // 显示到编辑框上
    _my_text_edit.append(str);

    // 更新当前输入的位置
    // 用于截断用户输入的命令时知道命令的起始位置。
    _content_string_current_idx = _my_text_edit.toPlainText().length();

    // 更新[当前输入行和列]的位置，为了判断能不能接受输入。
    update_cursor_position();


    //connect(&_cmd_process, SIGNAL(readyReadStandardOutput()), this, SLOT(on_cmd_process_readoutput()));
}

/**
 * @brief 终端用错误信息时自动调用这个槽函数
 * 相应信号[readyReadStandardError]
 */
void CMDWindow::on_cmd_process_readerror()
{
    // 将终端传来的字符串用[UTF8]进行编码
    // 并且在windows上删除 "\r"。linux上未定义。
    QTextCodec *GBK = QTextCodec::codecForName("GBK");
    //_cmd_process
    QString str = GBK->toUnicode(_cmd_process.readAllStandardError().data());
    str = str.replace("\r", "");

    // 显示到编辑框上
    _my_text_edit.append(str);
    
    // 更新当前输入的位置
    // 用于截断用户输入的命令时知道命令的起始位置。
    _content_string_current_idx = _my_text_edit.toPlainText().length();

    // 更新[当前输入行和列]的位置，为了判断能不能接受输入。
    update_cursor_position();
}

/**
 * @brief 当用户按下回车键，执行命令时，调用这个槽函数
 */
void CMDWindow::on_exe_cammand()
{
    if (_cmd_type == 0){
    // 获取编辑框中所有的内容
    QString total_input = _my_text_edit.toPlainText();

    // 从[当前输入索引]进行截断
    QString input_cammand = _my_text_edit.toPlainText().mid(_content_string_current_idx);

    // 更新[当前输入索引]
    _content_string_current_idx = total_input.length();

    // 命令追加一个回车键
    input_cammand += "\n";

    // 保存命令，用于控制台回显时把这部分内容删除掉
    _last_cammand = input_cammand;

    if (_last_cammand.startsWith("nc"))
    {
        _running_process_id = 1;
    }
    if (_last_cammand.startsWith("nc"))
    {
        _running_process_id = 1;
    }
    }

    qDebug() << "cmd>>" << _last_cammand;
    // 执行命令
    _cmd_process.write(_last_cammand.toLocal8Bit().constData());
_cmd_type = 0;

    if (_running_process_id == 1)
    {
        if (!timer->isActive())
        {
            _run_time = 2;
            timer->start(50);
        }

    }
    else
    {
        emit signal_execute_cammand_finished();
    }
    qDebug() << "signal_execute_cammand_finished";
}

/**
 * @brief [signal_update_cursor_position]信号的槽函数
 * 菜单栏点击了[控制台]选项时，会调用这个函数，主要是为了[更新输入行和列]
 */
void CMDWindow::slot_on_update_cursor_position()
{
    // 调用内部行数进行更新
    update_cursor_position();
}

void CMDWindow::on_timeout()
{
    if (_run_time > 0)
    {
        _my_text_edit.keyPressEvent(_my_text_edit._ke);
        _run_time--;
    }
    else
    {
        if (timer->isActive())
        {
            timer->stop();
        }
    }
}

/**
 * @brief 更新成员属性[当前输入位置的行和列]
 * 将光标移到编辑框的最后，更新[_cursor_column]和[_cursor_line]
 */
void CMDWindow::update_cursor_position()
{
    QTextCursor text_cursor = _my_text_edit.textCursor();
    text_cursor.movePosition(QTextCursor::End);
    _my_text_edit.setTextCursor(text_cursor);

    text_cursor = _my_text_edit.textCursor();
    _cursor_column = text_cursor.position() - text_cursor.block().position();
    QTextLayout* p_text_layout = text_cursor.block().layout();
    _cursor_line = p_text_layout->lineForTextPosition(_cursor_column).lineNumber() + text_cursor.block().firstLineNumber();

    check();
}

void CMDWindow::connect_signal_and_slot()
{
    // 输入框光标位置改变信号与槽
    connect(&_my_text_edit, SIGNAL(cursorPositionChanged()), this, SLOT(on_cursorPositionChanged()));
    // QProcess有输出信息时
    connect(&_cmd_process, SIGNAL(readyReadStandardOutput()), this, SLOT(on_cmd_process_readoutput()));
    connect(&_cmd_process, SIGNAL(readyReadStandardError()), this, SLOT(on_cmd_process_readerror()));

    // 当有命令需要执行时
    connect(&_my_text_edit, SIGNAL(exe_cammand()), this, SLOT(on_exe_cammand()));

    // 当需要更新输入位置的行、列时
    connect(this, SIGNAL(signal_update_cursor_position()), this, SLOT(slot_on_update_cursor_position()));
}
