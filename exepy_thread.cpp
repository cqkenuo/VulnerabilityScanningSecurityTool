#include "exepy_thread.h"
#include "gshared.h"
#include <QDebug>

//cpp
Exepy_thread::Exepy_thread(QObject* parent) : QObject (parent)
{
}
Exepy_thread::~Exepy_thread()
{
}
void Exepy_thread::start1()
{
    emit workStart();
    doWork();
}
void Exepy_thread::doWork()
{
    // 清空全局的漏洞poc链表.
    // 当存在漏铜的时候,会将这个漏洞信息显示到前端表格中,同时也会将对应的POC信息加入到这个链表中.
    // 用于在前端右键时,能确定是哪一个poc信息.
    GShared::filter_poc_exist_vulnerability.clear();
    // 把已经执行的次数设置为0。
    mainw->_scan_current_value = 0;

    // 输入主机的方式 [解析用户输入]
    if (mainw->_target_mode == TARGET_IPS_SRC_KEY_IN)
    {
        // 172.168.2.3
        // 172.168.3.3
        // 计算出总共的值
        // 加1 的原因是在用减的时候会少算1.比如。110-115；相减等于5，实际上要计算6次。
        int numberA = mainw->_target_ip_section.a_e - mainw->_target_ip_section.a_s == 0 
            ? 0 : mainw->_target_ip_section.a_e - mainw->_target_ip_section.a_s + 1;

        int numberB = mainw->_target_ip_section.b_e - mainw->_target_ip_section.b_s == 0
            ? 0 : mainw->_target_ip_section.b_e - mainw->_target_ip_section.b_s + 1;

        int numberC = mainw->_target_ip_section.c_e - mainw->_target_ip_section.c_s == 0
            ? 0 : mainw->_target_ip_section.c_e - mainw->_target_ip_section.c_s + 1;

        int numberD = mainw->_target_ip_section.d_e - mainw->_target_ip_section.d_s == 0
            ? 0 : mainw->_target_ip_section.d_e - mainw->_target_ip_section.d_s + 1;

        int number = numberA + numberB + numberC + numberD == 0 ? 1 : numberA + numberB + numberC + numberD;
        mainw->_scan_total_value = GShared::filter_poc_selected_list.size() * number;

        // 主机ip地址的A段、B段、C段
        int IPA = mainw->_target_ip_section.a_s;
        int IPB = mainw->_target_ip_section.b_s;
        int IPC = mainw->_target_ip_section.c_s;

        // 循环遍历ip地址的C段
        for (int current_row = 0; IPC <= mainw->_target_ip_section.c_e; IPC++)
        {
            // 循环遍历ip地址的D段
            for (int IPD = mainw->_target_ip_section.d_s; IPD <= mainw->_target_ip_section.d_e; current_row++, IPD++)
            {
                QString host = QString::number(IPA) + "." + QString::number(IPB) + "." + QString::number(IPC) + "." + QString::number(IPD);

                /**
                    扫描目标机器的端口
                */
                GShared::scan_port_thread.set_host(host);
                GShared::start_scan_port_thread();


                // 全局[已选POC链表]
                QList<POC>::iterator it_bg = GShared::filter_poc_selected_list.begin();
                QList<POC>::iterator it_ed = GShared::filter_poc_selected_list.end();
                for (; it_bg != it_ed; ++it_bg)
                {
                    if (mainw->_exe_python_script_thread_status == 1)
                        // 希望线程停止
                    {
                        goto WORK_END;
                    }
                    POC poc = *it_bg;

                    // 要执行的python脚本所在的路径
                    // 例如："C:/Users/nisodaisuki/Desktop/testJar/poc/tomcat/cve_2019_1938_P2.py";
                    QString py_script_path = GShared::program_poc_path + poc.folder + "/" + poc.name;
                   
                    // python版本
                    int pv = 2;
                    try
                    {
                        pv = atoi(poc.pyver.toStdString().c_str());
                    }
                    catch (...)
                    {

                    }

                    /*
                        遍历所有的端口
                    */
                    for (QString port : poc.ports)
                    {
                        int res = mainw->execute_python(py_script_path, pv, host, port, poc.tag);
                        QString qstr_res = QString::number(res);

                        // 只有在存在该漏洞的情况下才会显示到前端.
                        if  (POCENV_CHECKED_EXIST == qstr_res)
                        {
                            PY_RESULT r;
                            r.host = host;
                            r.host += ":";
                            r.host += port;
                            QString des = poc.description;
                            des = des.replace(CUSHREF_START, STDHREF_START);
                            des = des.replace(CUSHERF_END, STDHERF_END);
                            r.tag = QString(des.toStdString().c_str());
                            r.result = qstr_res;
                            emit mainw->signal_update_execute_python_script_result_table(r);
                            VULNERABILITY_INFO vi;
                            vi.pocInfo = poc;
                            vi.resultInfo = r;
                            GShared::filter_poc_exist_vulnerability.push_back(vi);
                            break;
                        }
                    }
                }
            }
        }
    }
    // 输入主机的方式 [解析IP列表文件]
    else if (mainw->_target_mode == TARGET_IPS_SRC_TEXT_FILE)
    {
        // 打开文件[ipslist]
        QFile file(GShared::program_ipslist_file);
        if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
            return;

        QTextStream in(&file);
        QString line = in.readLine();

        QStringList ips;
        
        // 循环读取一行，去除空格。如果以#开头，认为是注释
        while (!line.isNull())
        {
            line = line.trimmed();
            if(!line.startsWith("#"))
            {
                ips.push_back(line);
            }
            line = in.readLine();
        }

        // 计算出总共的值
        mainw->_scan_total_value = GShared::filter_poc_selected_list.size() * ips.size();
        
        QStringList::iterator it_b = ips.begin();
        QStringList::iterator it_e = ips.end();
        qDebug() << "iter size = " << GShared::filter_poc_selected_list.size();

        for (int current_row = 0; it_b != it_e; current_row++, it_b++)
        {
            QString host = *it_b;
            QList<POC>::iterator it_bg = GShared::filter_poc_selected_list.begin();
            QList<POC>::iterator it_ed = GShared::filter_poc_selected_list.end();
            for (; it_bg != it_ed; ++it_bg)
            {
                if (mainw->_exe_python_script_thread_status == 1)
                    // 希望线程停止
                {
                    goto WORK_END;
                }

                /**
                    扫描目标机器的端口
                */
                GShared::scan_port_thread.set_host(host);
                //GShared::start_scan_port_thread();

                POC poc = *it_bg;

                // 要执行的python脚本所在的路径
                // 例如："C:/Users/nisodaisuki/Desktop/testJar/poc/tomcat/cve_2019_1938_P2.py";
                QString py_script_path = GShared::program_poc_path + poc.folder + "/" + poc.name;
                
                // python版本
                int pv = 2;
                try
                {
                    pv = atoi(poc.pyver.toStdString().c_str());
                }
                catch (...)
                {

                }

                /*
                    遍历所有的端口
                */
                for (QString port : poc.ports)
                {
                    int res = mainw->execute_python(py_script_path, pv, host, port, poc.tag);
                    // 只有在存在该漏洞的情况下才会显示到前端.
                    QString qstr_res = QString::number(res);
                    if  (POCENV_CHECKED_EXIST == qstr_res)
                    {
                        PY_RESULT r;
                        r.host = host;
                        r.host += ":";
                        r.host += port;
                        QString des = poc.description;
                        des = des.replace(CUSHREF_START, STDHREF_START);
                        des = des.replace(CUSHERF_END, STDHERF_END);
                        r.tag = QString(des.toStdString().c_str());
                        r.result = QString::number(res);
                        emit mainw->signal_update_execute_python_script_result_table(r);
                        VULNERABILITY_INFO vi;
                        vi.pocInfo = poc;
                        vi.resultInfo = r;
                        GShared::filter_poc_exist_vulnerability.push_back(vi);
                    }
                }
            }
        }
    }
   
WORK_END:
    emit mainw->signal_exe_pyscript_thread_finished();
    // 发出 结束 的信号
    emit workFinished();
}


