#include "gshared.h"








QString GShared::program_path;

QString GShared::python2_path;
QString GShared::python3_path;
/////////////程序目录下//////////////////////
// 全局poc配置文件[gconfig.xml]
QString GShared::poc_xml_file;

// 程序目录下poc文件夹
QString GShared::program_poc_path;
// 程序目录下exp文件夹
QString GShared::program_exp_dir;
// ip列表文件
// 程序目录/ipslist
QString GShared::program_ipslist_file;

// config.json所在的路径
QString GShared::program_poc_lib_configjson_file;

// 程序目录下，innertools文件夹dd
QString GShared::program_tools;

// 程序目录下，logs文件夹
QString GShared::program_logs;

QString GShared::poc_list_widget_title = QString::fromLocal8Bit("漏洞列表");

QFont GShared::ubuntu_font;

//菜单栏图标的初始化
QIcon GShared::menu_icon_main_normal;
QIcon GShared::menu_icon_main_clicked;
QIcon GShared::menu_icon_editIP_normal;
QIcon GShared::menu_icon_editIP_clicked;
QIcon GShared::menu_icon_console_normal;
QIcon GShared::menu_icon_console_clicked;
QIcon GShared::menu_icon_setting_normal;
QIcon GShared::menu_icon_setting_clicked;

QStringList GShared::sys_filter_list;
QStringList GShared::app_filter_list;
QStringList GShared::cms_filter_list;
QList<POC> GShared::filter_poc_list;
QList<POC> GShared::filter_poc_selected_list;
QList<VULNERABILITY_INFO> GShared::filter_poc_exist_vulnerability;

// 扫描端口线程
THREAD_SCANPORT GShared::scan_port_thread;


GShared::GShared()
{
}

void GShared::init_gshared()
{
    
    program_path = QDir::currentPath();
    python2_path = program_path + "/pythonInterpreter/python27/python2.exe";
    python3_path = program_path + "/pythonInterpreter/python37/python3.exe";

    poc_xml_file = program_path + "/gconfig.xml";
    program_poc_path = program_path + "/poc/";
    program_exp_dir = program_path + "/exp/";
    program_ipslist_file = program_path + "/" + Q_FILE_NAME_IPS_LIST_TXT;
    program_poc_lib_configjson_file = program_poc_path + "lib/config.json";

    program_tools = program_path + "/innertools/";

    program_logs = program_path + "/logs/";

    //菜单栏图标的初始化
    menu_icon_main_normal = QIcon(GShared::program_path + "/src/" + MENU_ICON_MAIN_NORMAL);
    menu_icon_main_clicked = QIcon(GShared::program_path + "/src/" + MENU_ICON_MAIN_CLICKED);
    menu_icon_editIP_normal = QIcon(GShared::program_path + "/src/" + MENU_ICON_EDIT_IPS_TXT_NORMAL);
    menu_icon_editIP_clicked = QIcon(GShared::program_path + "/src/" + MENU_ICON_EDIT_IPS_TXT_CLICKED);
    menu_icon_console_normal = QIcon(GShared::program_path + "/src/" + MENU_ICON_CONSOLE_NORMAL);
    menu_icon_console_clicked = QIcon(GShared::program_path + "/src/" + MENU_ICON_CONSOLE_CLICKED);
    menu_icon_setting_normal = QIcon(GShared::program_path + "/src/" + MENU_ICON_SETTING_NORMAL);
    menu_icon_setting_clicked = QIcon(GShared::program_path + "/src/" + MENU_ICON_SETTING_CLICKED);

    QDir* dir = new QDir;
    if (!dir->exists(program_logs))
    {
        dir->mkdir(program_logs);
    }

    QString family = loadFontFamilyFromFiles("./src/nisof.ttf");
    ubuntu_font.setFamily(family);
    //ubuntu_font.setPointSize(12);
}

// 如果当前程序的路径大于150个字节返回false；
// 否则返回true。
// 用于检查程序所在的路径是否过深。
// 如果过深的话，就无法修改pip.exe中的python路径。
bool GShared::check_path_lenth(QWidget* widget)
{
    if (program_path.size() >= 130)
    {
        QMessageBox::information(widget, QString::fromLocal8Bit("too long"), QString::fromLocal8Bit("程序所在路径应小于150个字节p"));
        return false;
    }
    return true;
}

void GShared::modify_python2pipexe_file()
{
    long pip_exe_offset = 0x19002;
    QString pip_exe_path = program_path + "/pythonInterpreter/python27/Scripts/pip2.exe";
    
    //得到python2.exe的绝对路径，然后把这个路径写道pip2.exe中
    const char* p_p2_exe_path = python2_path.toStdString().c_str();

    FILE* pf_pipexe = fopen(pip_exe_path.toStdString().c_str(), "rb+");
    // 检查文件是否成功。
    if (pf_pipexe == nullptr)
    {
        return;
    }

    fseek(pf_pipexe, pip_exe_offset, SEEK_SET);
    fwrite(python2_path.toStdString().c_str(), strlen(p_p2_exe_path)+1, 1, pf_pipexe);
    fclose(pf_pipexe);
}

void GShared::modify_python3pipexe_file()
{
    long pip_exe_offset = 0x19002;
    QString pip_exe_path = program_path + "/pythonInterpreter/python37/Scripts/pip3.exe";

    //得到python3.exe的绝对路径，然后把这个路径写道pip3.exe中
    const char* p_p3_exe_path = python3_path.toStdString().c_str();

    FILE* pf_pipexe = fopen(pip_exe_path.toStdString().c_str(), "rb+");
    // 检查文件是否成功。
    if (pf_pipexe == nullptr)
    {
        return;
    }

    fseek(pf_pipexe, pip_exe_offset, SEEK_SET);
    fwrite(python3_path.toStdString().c_str(), strlen(p_p3_exe_path) + 1, 1, pf_pipexe);
    fclose(pf_pipexe);
}

QString GShared::get_datatime()
{
    QDateTime current_date_time = QDateTime::currentDateTime();
    return current_date_time.toString("MMddhhmmss");
}

QString GShared::loadFontFamilyFromFiles(const QString &fontFileName)
{
    static QHash<QString, QString> tmd;
    if (tmd.contains(fontFileName)) {
        return tmd.value(fontFileName);
    }
    QString font = "";
    QFile fontFile(fontFileName);
    qDebug() << "FONR FILE : " << fontFile.fileName();
    if(!fontFile.open(QIODevice::ReadOnly)) {
        qDebug()<<"Open font file error";
        return font;
    }

    int loadedFontID = QFontDatabase::addApplicationFontFromData(fontFile.readAll());
    QStringList loadedFontFamilies = QFontDatabase::applicationFontFamilies(loadedFontID);
    if(!loadedFontFamilies.empty()) {
        font = loadedFontFamilies.at(0);
    }
    fontFile.close();

    if (!(font.isEmpty()))
        tmd.insert(fontFileName, font);
    return font;
}

QString GShared::getHostIpAddress()
{

    QString strIpAddress;
        QList<QHostAddress> ipAddressesList = QNetworkInterface::allAddresses();
        // 获取第一个本主机的IPv4地址
        int nListSize = ipAddressesList.size();
        for (int i = 0; i < nListSize; ++i)
        {
               if (ipAddressesList.at(i) != QHostAddress::LocalHost &&
                   ipAddressesList.at(i).toIPv4Address()) {
                   strIpAddress = ipAddressesList.at(i).toString();
                   break;
               }
         }
         // 如果没有找到，则以本地IP地址为IP
         if (strIpAddress.isEmpty())
            strIpAddress = QHostAddress(QHostAddress::LocalHost).toString();
         return strIpAddress;
}

void GShared::start_scan_port_thread()
{
    // 准备开始真正的执行python脚本
    // 新建一个线程
    QThread* m_workerThread = new QThread();
    // 新建一个真正工作的线程
    //THREAD_SCANPORT* worker_thread = new THREAD_SCANPORT();

    QObject::connect(m_workerThread, &QThread::started, &scan_port_thread, &THREAD_SCANPORT::start1);//on_exe_pyscript_thread_finished
    QObject::connect(m_workerThread, &QThread::finished, m_workerThread, &QThread::deleteLater);
    QObject::connect(&scan_port_thread, &THREAD_SCANPORT::workFinished, &scan_port_thread, &THREAD_SCANPORT::deleteLater);
    QObject::connect(&scan_port_thread, &THREAD_SCANPORT::workFinished, m_workerThread, &QThread::quit);

    scan_port_thread.moveToThread(m_workerThread);
    m_workerThread->start();
}

void GShared::get_json()
{
    QFile loadFile("C:\\Users\\nisodaisuki\\Documents\QTProject\\VulnerabilityScanningSecurityTool-plus\\poc\\config.json");

    if(!loadFile.open(QIODevice::ReadOnly))
    {
        qDebug() << "could't open projects json";
        return;
    }

    QByteArray allData = loadFile.readAll();
    loadFile.close();

    QJsonParseError json_error;
    QJsonDocument jsonDoc(QJsonDocument::fromJson(allData, &json_error));

    if(json_error.error != QJsonParseError::NoError)
    {
        qDebug() << "json error!";
        return;
    }

    QJsonObject rootObj = jsonDoc.object();

    QStringList keys = rootObj.keys();
    for(int i = 0; i < keys.size(); i++)
    {
        qDebug() << "key" << i << " is:" << keys.at(i);
    }

    //因为是预先定义好的JSON数据格式，所以这里可以这样读取
    if(rootObj.contains("first fruit") && rootObj["first fruit"].isObject())
    {
        QJsonObject subObj = rootObj["first fruit"].toObject();
        if (subObj.contains("describe") && subObj["describe"].isString())
        {
            qDebug() << "describe is:" << subObj["describe"].toString();
        }
        if (subObj.contains("icon") && subObj["icon"].isString())
        {
            qDebug() << "icon is:" << subObj["icon"].toString();
        }
        if (subObj.contains("name") && subObj["name"].isString())
        {
            qDebug() << "name is:" << subObj["name"].toString();
        }
    }

    if(rootObj.contains("second fruit") && rootObj["second fruit"].isObject())
    {
        QJsonObject subObj = rootObj["second fruit"].toObject();
        if (subObj.contains("describe") && subObj["describe"].isString())
        {
            qDebug() << "describe is:" << subObj["describe"].toString();
        }
        if (subObj.contains("icon") && subObj["icon"].isString())
        {
            qDebug() << "icon is:" << subObj["icon"].toString();
        }
        if (subObj.contains("name") && subObj["name"].isString())
        {
            qDebug() << "name is:" << subObj["name"].toString();
        }
    }

    if(rootObj.contains("three fruit array") && rootObj["three fruit array"].isArray())
    {
        QJsonArray subArray = rootObj.value("three fruit array").toArray();
        for(int i = 0; i< subArray.size(); i++)
        {
            if (subArray[i].isString())
            {
                qDebug() << i<<" value is:" << subArray.at(i).toString();
            }
        }
    }
}
