#include "mainwindow.h"
#include "ui_mainwindow.h"
#include "exepy_thread.h"
#include <QCheckBox>
#include <QFuture>

#include <QTableWidget>
#include <QButtonGroup>



#include "exepy_thread.h"
#include "gshared.h"

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    if (!GShared::check_path_lenth(this))
    {
        exit(0);
    }

    // 修正pip.exe
    GShared::modify_python2pipexe_file();
    GShared::modify_python3pipexe_file();
    // 设置窗口标题
    this->setWindowIcon(QIcon("./src/cm.png"));
    setWindowTitle(QString::fromLocal8Bit(MAIN_WINDOW_TITLE));

    this->setFont(GShared::ubuntu_font);

    // 初始化菜单按钮列表
    set_list_button();

    // 解析xml文件
    // 通过解析xml函数获得初始的POC列表
    // 同时把解析出来的POC列表设置为总POC列表和已选POC列表
    _poclist_OBJ.parse_poc_xml();

    // 初始化POC列表
    set_poc_list_widget(GShared::filter_poc_list);

    // 初始化POC筛选组件
    set_poc_filter();

    // 设置执行python执行后的[结果表]
    set_result_table_widget();

    // 增加窗口
    // 1.增加编辑ip列表文本的窗口
    // 2.控制台窗口
    ui->mainshow_layout->addWidget(&_edit_ips_txt_window);
    ui->mainshow_layout->addWidget(&_cmd_window);
    ui->mainshow_layout->addWidget(&_setting_window);
    _edit_ips_txt_window.hide();
    _cmd_window.hide();
    _setting_window.hide();

    // 绑定信号与槽函数
    set_connection();

    // 进入用户模式
    is_user_mode = true;
}

MainWindow::~MainWindow()
{
    delete ui;
}

/**
 * @brief 绑定信号和槽函数
 */
void MainWindow::set_connection()
{
    // 如果信号/槽函数中使用了自定义的类型，需要注册成元类型
    qRegisterMetaType<PY_RESULT>("PY_RESULT");

    // python脚本执行完  -->   更新[结果表]
    connect(this, SIGNAL(signal_update_execute_python_script_result_table(PY_RESULT)), this, SLOT(slot_on_update_execute_python_script_result_table(PY_RESULT)));

    // 将筛选组件中的 筛选条件的[当前文本改变信号]都指向一个槽函数。
    connect(ui->sys_cb, SIGNAL(currentTextChanged(QString)), this, SLOT(on_comboBox_currentTextChanged()));
    connect(ui->app_cb, SIGNAL(currentTextChanged(QString)), this, SLOT(on_comboBox_currentTextChanged()));
    connect(ui->cms_cb, SIGNAL(currentTextChanged(QString)), this, SLOT(on_comboBox_currentTextChanged()));

    // 线程结束信号和处理线程结束槽函数绑定
    connect(this, SIGNAL(signal_exe_pyscript_thread_finished()), this, SLOT(on_exe_pyscript_thread_finished()));

    // 设置界面，日志设置发生改变时
    connect(&_setting_window, SIGNAL(signal_log_comboBox_changed(SETTINGWINDOW_COMBOBOX_LOG)), this, SLOT(on_settingwindow_log_comboBox_changed(SETTINGWINDOW_COMBOBOX_LOG)));
}

/**
 * @brief 设置菜单列表
 */
void MainWindow::set_list_button()
{
    // 图标文件的绝对路径
    QString main_file_name = GShared::program_path + "/src/" + MENU_ICON_MAIN;
    qDebug() << main_file_name;
    QString edit_ips_txt_file_name = GShared::program_path + "/src/" + MENU_ICON_EDIT_IPS_TXT;
    QString console_file_name = GShared::program_path + "/src/" + MENU_ICON_CONSOLE;
    QString setting_file_name = GShared::program_path + "/src/" + MENU_ICON_SETTING;

    // 新建图标列表项
    QListWidgetItem* menu_main = new QListWidgetItem(QIcon(main_file_name), QSTR("漏洞扫描"));
    QListWidgetItem* menu_edit_ip = new QListWidgetItem(QIcon(edit_ips_txt_file_name), QSTR("编辑IP列表"));
    QListWidgetItem* menu_cmd = new QListWidgetItem(QIcon(console_file_name), QSTR("终端"));
    QListWidgetItem* menu_setting = new QListWidgetItem(QIcon(setting_file_name), QSTR("设置"));

    // 加入菜单列表
    ui->menu_list->addItem(menu_main);
    ui->menu_list->addItem(menu_edit_ip);
    ui->menu_list->addItem(menu_cmd);
    ui->menu_list->addItem(menu_setting);
}

/**
 * @brief 初始化主界面筛选条件的组件
 */
void MainWindow::set_poc_filter()
{
    // poc筛选组件的中的 [系统] 筛选条件
    // 第一项：默认不选择
    // 后面从xml文件中读取的
    ui->sys_cb->addItem(COMBOX_NO_CHOOSE);
    QStringList::iterator sys_it_bg = GShared::sys_filter_list.begin();
    QStringList::iterator sys_it_ed = GShared::sys_filter_list.end();
    for (; sys_it_bg != sys_it_ed; ++sys_it_bg)
    {
        ui->sys_cb->addItem((*sys_it_bg));
    }

    // poc筛选组件的中的 [中间件] 筛选条件
    // 第一项：默认不选择
    // 后面从xml文件中读取的
    ui->app_cb->addItem(COMBOX_NO_CHOOSE);
    QStringList::iterator app_it_bg = GShared::app_filter_list.begin();
    QStringList::iterator app_it_ed = GShared::app_filter_list.end();
    for (; app_it_bg != app_it_ed; ++app_it_bg)
    {
        ui->app_cb->addItem((*app_it_bg));
    }
    // poc筛选组件的中的 [CMS] 筛选条件
    // 第一项：默认不选择
    // 后面从xml文件中读取的
    ui->cms_cb->addItem(COMBOX_NO_CHOOSE);
    QStringList::iterator cms_it_bg = GShared::cms_filter_list.begin();
    QStringList::iterator cms_it_ed = GShared::cms_filter_list.end();
    for (; cms_it_bg != cms_it_ed; ++cms_it_bg)
    {
        ui->cms_cb->addItem((*cms_it_bg));
    }

    // 初始化ip段的下拉选择项
    ui->ip_section->addItem(COMBOX_NO_CHOOSE);
    ui->ip_section->addItem(IP_SECTION_24);
    ui->ip_section->addItem(IP_SECTION_16);
}

/**
 * @brief 设置poc列表信息
 * @param 保存POC列表的值
 */
void MainWindow::set_poc_list_widget(QList<POC> poc_list)
{
    // 清空POC列表中的内容
    ui->poc_lstw->clear();

    // POC列表的标题
    QListWidgetItem *item_title = new QListWidgetItem();
    item_title->setCheckState(Qt::CheckState::Checked);     // 设置复选窗口(默认为选择)
    item_title->setText(GShared::poc_list_widget_title);    // 设置列表的内容
    ui->poc_lstw->addItem(item_title);                      // 在ListWidget中添加一个条目

    // 将poc_list列表中值在POC列表中显示
    QList<POC>::iterator it_bg = poc_list.begin();
    QList<POC>::iterator it_ed = poc_list.end();
    for(int i = 0; it_bg != it_ed; it_bg++, i++)
    {
        QString show_text = QString((*it_bg).name.c_str());
        show_text.replace(".py", "");
        show_text += "\n";
        QString tag = QString((*it_bg).tag.c_str());
        show_text += tag;
        QListWidgetItem *item = new QListWidgetItem();
        item->setCheckState(Qt::CheckState::Checked);
        item->setText(show_text);
        ui->poc_lstw->addItem(item);                        //在ListWidget中添加一个条目
    }
}

/**
 * @brief 更新poc列表信息
 * @param 保存最新POC列表的值
 */
//void MainWindow::update_poc_list_widget(QList<POC> poc_list)
//{
//    QList<POC>::iterator it_bg = poc_list.begin();
//    QList<POC>::iterator it_ed = poc_list.end();
//    for(int i = 0; it_bg != it_ed; it_bg++, i++)
//    {
//        // POC结构体中tag为列表文本
//        QString tag = QString((*it_bg).tag.c_str());
//        QListWidgetItem *item = new QListWidgetItem();
//        item->setCheckState(Qt::CheckState::Checked);
//        ui->poc_lstw->addItem(item);
//    }
//}

/**
 * @brief 设置执行python脚本后的结果表
 */
void MainWindow::set_result_table_widget()
{
    // 设置[结果表]为3列
    //ui->tbw_result->setColumnCount(2);
    // [结果表]标题
    QStringList strs = { QSTR("主机"), QSTR("描述") };
    
    ui->tbw_result->setHorizontalHeaderLabels(strs);

    // 行：根据内容修改大小
    ui->tbw_result->resizeRowsToContents();
}

/**
 * @brief 根据用户的筛选条件更新POC列表
 */
void MainWindow::update_filter_poc()
{
    // 如果非用户模式就什么都不执行
    if  (!is_user_mode)
    {
        return;
    }

    // 把符合条件的POC存入一个新的POC列表
    QList<POC> new_poc_filter_list;

    // 用户当前的选择
    string sys_filter = ui->sys_cb->currentText().toStdString();
    string app_filter = ui->app_cb->currentText().toStdString();
    string cms_filter = ui->cms_cb->currentText().toStdString();

    /*
        遍历全局poc列表
        和筛选条件一个个进行匹配
        如果全都满足条件就加入一个暂存的poc列表
        最后把缓存的poc链表复制给全局的选择poc链表
    */
    QList<POC>::iterator bg = GShared::filter_poc_list.begin();
    QList<POC>::iterator ed = GShared::filter_poc_list.end();
    for (; bg != ed; ++bg)
    {
        POC poc = *bg;

        // 过滤系统[sys]字段
        if  (COMBOX_NO_CHOOSE != sys_filter)
        {
            if (poc.sys != sys_filter)
            {
                // 不满足条件，测试下一个POC
                continue;
            }
        }

        // 过滤中间件[app]字段
        if (COMBOX_NO_CHOOSE != app_filter)
        {
            if (poc.app != app_filter)
            {
                // 不满足条件，测试下一个POC
                continue;
            }
        }

        // 过滤CMS[cms]字段
        if (COMBOX_NO_CHOOSE != cms_filter)
        {
            if (poc.cms != cms_filter)
            {
                // 不满足条件，测试下一个POC
                continue;
            }
        }

        new_poc_filter_list.push_back(poc);

    }

    // 更新全局已选POC链表
    GShared::filter_poc_selected_list = new_poc_filter_list;

    // 更新POC列表窗口
    set_poc_list_widget(GShared::filter_poc_selected_list);
}

void MainWindow::on_execute_exp()
{
    /**
        执行exp
    */
    qDebug() << "on_execute_exp : row = " << _contextMenu_row << " col = " << _contextMenu_col;
}

/**
 * @brief 执行python的单元
 * @param py_scrip_file 指定要执行的python脚本
 * @param python_version    选用python的版本
 * @param params            传递的参数（json脚本的路径 ip地址）
 * @return
 */
int MainWindow::execute_python(QString py_scrip_file, int python_version, QString host, QString tag)
{
    if (python_version == 2)
    {
        _py_cammand = GShared::python2_path + " " + py_scrip_file + " " + GShared::program_poc_lib_configjson_file + " " + host + " \n";
    }
    else if (python_version == 3)
    {
        _py_cammand = GShared::python3_path + " " + py_scrip_file + " " + GShared::program_poc_lib_configjson_file + " " + host + " \n";
    }
    else
        // 默认用python2执行
    {
        _py_cammand = GShared::python2_path + " " + py_scrip_file + " " + GShared::program_poc_lib_configjson_file + " " + host + " \n";
    }
    
    // 创建一个进程用于执行python文件
    p_exe_python_script_process = new QProcess(this);

    // 执行python脚本的进程  -->  输出信息
    //qRegisterMetaType<CLog>("CLog");

    connect(p_exe_python_script_process, SIGNAL(readyReadStandardOutput()), this, SLOT(OnReadData()));

    // 开启日志记录功能
    if (_setting.is_open_log())
    {
        CLog _p_logfile(_logdir + "/" + host);
        _p_logfile.write_log(host + "  <<  >>  " + tag + "\n");
    }
    
    _hhost = host;

    // 打开一个cmd
    p_exe_python_script_process->start("cmd.exe");
    // 等待cmd打开完毕
    p_exe_python_script_process->waitForStarted();

    // 输入python命令，要求他启动指定脚本。
    // 例如：>python.exe script.py jsonfile.json 172.16.5.113
    //QMessageBox::information(this, "cammand", py_cammand);
    p_exe_python_script_process->write(_py_cammand.toStdString().c_str());

    // 退出python环境
    p_exe_python_script_process->write("exit()\n");

    // 退出cmd
    p_exe_python_script_process->waitForFinished();

    // 返回的是python脚本exit(int)函数中的int值。
    return p_exe_python_script_process->exitCode();
}

/**
 * @brief 当筛选组件筛选条件的任意下拉框改变时，执行这个槽函数
 */
void MainWindow::on_comboBox_currentTextChanged()
{
    update_filter_poc();
}

/**
 * @brief 用户点击了 [检测] 按钮的槽函数
 * 主要解析了用户的输入，设置了 _target_ip_section 变量
 * 创建工作线程进行执行python代码
 */
void MainWindow::on_btn_exe_poc_clicked()
{
    // 设置[检测]按钮不可用。为了防止用户在运行中不断点击按钮，这可能导致程序崩溃。
    // 当程序执行完成后，由 工作线程 发出 信号，来使按钮可用。
    // 设置[停止]按钮可用。可以让用户随时停止工作
    // 当程序执行完后，在[on_exe_pyscript_thread_finished]槽函数中设置不可用。
    ui->btn_exe_poc->setEnabled(false);
    ui->btn_exe_stop->setEnabled(true);
    
    // 清空原始的行数。
    ui->tbw_result->setRowCount(0);

    // 清空全局python执行结果表
    GShared::exec_python_script_result_list.clear();


    // 新建日志文件夹
     //get_datatime
    QDir* dir = new QDir;
    _logdir = GShared::program_logs+GShared::get_datatime();
    if (!dir->exists(_logdir))
    {
        dir->mkdir(_logdir);
    }

    // 判断用户选择的执行模式
    // 用户希望工具解析 [输入框] 中的内容来对目标主机进行检测
    if (_target_mode == TARGET_IPS_SRC_KEY_IN)
    {
        /*
            用户在输入框中输入字符串共有3中规则。
            1. 单个IP         特征：无-(中划线)符号 IP段下拉框为 [未选择]
            2. IP段           特征：无-(中划线)符号 IP段下拉框为 [非未选择]
            3. 连续单IP       特征：有-(中划线)符号 IP段下拉框为 [未选择]
        */


        // 获取用户在 target 编辑框中输入的字符串
        QString usr_input = ui->edt_target->text();
        // IP下拉框的选择
        QString cb_ip_section = ui->ip_section->currentText();

        //2. IP段           特征：无-(中划线)符号 IP段下拉框为 [非未选择]
        if ( (!usr_input.contains("-")) && (cb_ip_section != COMBOX_NO_CHOOSE))
        {
            // 将输入的文件按 点 进行分割，准备进行检测
            QStringList ip_split4 = usr_input.split(".");

            // 分割出来的数量不等于4，认为用户输入不正确
            if (ip_split4.size() != 4)
            {
                // 显示提示弹窗
                QMessageBox::information(this, QString::fromLocal8Bit("提示"), QString::fromLocal8Bit("输入格式错误输入方式。输入格式有以下方式：\r\n1. A.B.C.D-E 连续的IP地址\r\n2. A.B.C.x 选择ip段\r\n3. A.B.C.D 单目标执行\r\n4. 选择从文件中读取"));
                
                // 使按钮可用
                ui->btn_exe_poc->setEnabled(true);

                return;
            }

            // 判断用户选择了哪一个段
            // 支持/24和/16
            if (cb_ip_section == IP_SECTION_24)
            {
                // 将字符串转成数字，如果没有问题就设置 IP_SECTION (目标IP段)结构体
                try {
                    _target_ip_section.a_s = std::stoi(ip_split4.at(0).toStdString());
                    _target_ip_section.a_e = _target_ip_section.a_s;

                    _target_ip_section.b_s = std::stoi(ip_split4.at(1).toStdString());
                    _target_ip_section.b_e = _target_ip_section.b_s;

                    _target_ip_section.c_s = std::stoi(ip_split4.at(2).toStdString());
                    _target_ip_section.c_e = _target_ip_section.c_s;

                    _target_ip_section.d_s = 1;
                    _target_ip_section.d_e = 254;
                }
                catch (...)
                {
                    // 显示提示弹窗
                    QMessageBox::information(this, QString::fromLocal8Bit("提示"), QString::fromLocal8Bit("输入格式错误输入方式。输入格式有以下方式：\r\n1. A.B.C.D-E 连续的IP地址\r\n2. A.B.C.x 选择ip段\r\n3. A.B.C.D 单目标执行\r\n4. 选择从文件中读取"));

                    // 使按钮可用
                    ui->btn_exe_poc->setEnabled(true);

                    return;
                }
            }
            else if (cb_ip_section == IP_SECTION_16)
            {
                // 将字符串转成数字，如果没有问题就设置 IP_SECTION (目标IP段)结构体
                try {
                    _target_ip_section.a_s = std::stoi(ip_split4.at(0).toStdString());
                    _target_ip_section.a_e = _target_ip_section.a_s;

                    _target_ip_section.b_s = std::stoi(ip_split4.at(1).toStdString());
                    _target_ip_section.b_e = _target_ip_section.b_s;

                    _target_ip_section.c_s = 1;
                    _target_ip_section.c_e = 254;

                    _target_ip_section.d_s = 1;
                    _target_ip_section.d_e = 254;
                }
                catch (...)
                {
                    // 显示提示弹窗
                    QMessageBox::information(this, QString::fromLocal8Bit("提示"), QString::fromLocal8Bit("输入格式错误输入方式。输入格式有以下方式：\r\n1. A.B.C.D-E 连续的IP地址\r\n2. A.B.C.x 选择ip段\r\n3. A.B.C.D 单目标执行\r\n4. 选择从文件中读取"));

                    // 使按钮可用
                    ui->btn_exe_poc->setEnabled(true);

                    return;
                }
            }
        }
        //3. 连续单IP       特征：有 - (中划线)符号 IP段下拉框为[未选择]
        else if ( (usr_input.contains("-")) && (cb_ip_section == COMBOX_NO_CHOOSE) )
        {
            // 按中划线进行分割。理论上应该会被分割成2个。前面为一个IP地址，后面为一个数字(终点IP)
            QStringList splits2 = usr_input.split("-");

            // 如果分割出来的长度不为2，我们认为用户输入有误，提示用户正确输入。
            if (splits2.size() != 2)
            {
                // 显示提示弹窗
                QMessageBox::information(this, QString::fromLocal8Bit("提示"), QString::fromLocal8Bit("输入格式错误输入方式。输入格式有以下方式：\r\n1. A.B.C.D-E 连续的IP地址\r\n2. A.B.C.x 选择ip段\r\n3. A.B.C.D 单目标执行\r\n4. 选择从文件中读取"));
                
                // 使按钮可用
                ui->btn_exe_poc->setEnabled(true);

                return;
            }

            // 将前面的IP地址按 点 进行分割
            // 如果分割出来的长度不等于4，认为输入不正确。
            // 把分割出来的[四个字符串]和 [-中划线后的字符串] 转成数字，如果在转的过程中出错，认为输入不正确。
            QStringList ip_split4 = splits2.at(0).split(".");
            
            if (ip_split4.size() != 4)
            {
                // 显示提示弹窗
                QMessageBox::information(this, QString::fromLocal8Bit("提示"), QString::fromLocal8Bit("输入格式错误输入方式。输入格式有以下方式：\r\n1. A.B.C.D-E 连续的IP地址\r\n2. A.B.C.x 选择ip段\r\n3. A.B.C.D 单目标执行\r\n4. 选择从文件中读取"));

                // 使按钮可用
                ui->btn_exe_poc->setEnabled(true);

                return;
            }

            // 将字符串转成数字，如果没有问题就设置 IP_SECTION (目标IP段)结构体
            try {
                qDebug() << "连续单IP";
                _target_ip_section.a_s = std::stoi(ip_split4.at(0).toStdString());
                _target_ip_section.a_e = _target_ip_section.a_s;

                _target_ip_section.b_s = std::stoi(ip_split4.at(1).toStdString());
                _target_ip_section.b_e = _target_ip_section.b_s;

                _target_ip_section.c_s = std::stoi(ip_split4.at(2).toStdString());
                _target_ip_section.c_e = _target_ip_section.c_s;

                _target_ip_section.d_s = std::stoi(ip_split4.at(3).toStdString());
                _target_ip_section.d_e = std::stoi(splits2.at(1).toStdString());
            }
            catch (...) 
            {
                // 显示提示弹窗
                QMessageBox::information(this, QString::fromLocal8Bit("提示"), QString::fromLocal8Bit("输入格式错误输入方式。输入格式有以下方式：\r\n1. A.B.C.D-E 连续的IP地址\r\n2. A.B.C.x 选择ip段\r\n3. A.B.C.D 单目标执行\r\n4. 选择从文件中读取"));

                // 使按钮可用
                ui->btn_exe_poc->setEnabled(true);

                return;
            }
        }
        // 1. 单个IP         特征：无-(中划线)符号 IP段下拉框为 [未选择]
        else if ((!usr_input.contains("-")) && (cb_ip_section == COMBOX_NO_CHOOSE))
        {
            // 将用户的输入按照点进行分割
            QStringList splits = usr_input.split(".");

            // 如果分割出来的长度不等于4，认为输入不正确。
            if (splits.size() != 4)
            {
                // 显示提示弹窗
                QMessageBox::information(this, QString::fromLocal8Bit("提示"), QString::fromLocal8Bit("输入格式错误输入方式。输入格式有以下方式：\r\n1. A.B.C.D-E 连续的IP地址\r\n2. A.B.C.x 选择ip段\r\n3. A.B.C.D 单目标执行\r\n4. 选择从文件中读取"));

                // 使按钮可用
                ui->btn_exe_poc->setEnabled(true);

                return;
            }

            // 将字符串转成数字，如果没有问题就设置 IP_SECTION (目标IP段)结构体
            try {
                _target_ip_section.a_s = std::stoi(splits.at(0).toStdString());
                _target_ip_section.a_e = _target_ip_section.a_s;

                _target_ip_section.b_s = std::stoi(splits.at(1).toStdString());
                _target_ip_section.b_e = _target_ip_section.b_s;

                _target_ip_section.c_s = std::stoi(splits.at(2).toStdString());
                _target_ip_section.c_e = _target_ip_section.c_s;

                _target_ip_section.d_s = std::stoi(splits.at(3).toStdString());
                _target_ip_section.d_e = _target_ip_section.d_s;
            }
            catch (...) 
            {
                // 显示提示弹窗
                QMessageBox::information(this, QString::fromLocal8Bit("提示"), QString::fromLocal8Bit("输入格式错误输入方式。输入格式有以下方式：\r\n1. A.B.C.D-E 连续的IP地址\r\n2. A.B.C.x 选择ip段\r\n3. A.B.C.D 单目标执行\r\n4. 选择从文件中读取"));

                // 使按钮可用
                ui->btn_exe_poc->setEnabled(true);

                return;
            }
        }
    }
    // 用户希望工具从 [文本文件] 中读取目标主机进行检测
    else if (_target_mode == TARGET_IPS_SRC_TEXT_FILE)
    {
        // 这里不需要做什么工作，读取文件什么都在线程内完成。
    }
    else
    {
        //非输入 非文本，认为程序出了问题。
        // 使按钮可用
        ui->btn_exe_poc->setEnabled(true);

        return;
    }

    // 准备开始真正的执行python脚本
    // 新建一个线程
    QThread* m_workerThread = new QThread();
    // 新建一个真正工作的线程
    Exepy_thread* worker_thread = new Exepy_thread();

    connect(m_workerThread, &QThread::started, worker_thread, &Exepy_thread::start1);//on_exe_pyscript_thread_finished
    connect(m_workerThread, &QThread::finished, m_workerThread, &QThread::deleteLater);
    connect(worker_thread, &Exepy_thread::workFinished, worker_thread, &Exepy_thread::deleteLater);
    connect(worker_thread, &Exepy_thread::workFinished, m_workerThread, &QThread::quit);

    worker_thread->mainw = this;
    worker_thread->moveToThread(m_workerThread);
    m_workerThread->start();
}

/**
 * @brief 当控制台有输出时，这个函数被调用。
 * 设计用于日志记录。
 */
void MainWindow::OnReadData()
{
    // 开启日志记录功能
    if (!_setting.is_open_log())
    {
        p_exe_python_script_process->readAllStandardOutput();
        return;
    }

    CLog llod(_logdir + "/" + _hhost);
    QString path = GShared::program_path;
    path = path.replace("/", "");
    path = path.replace("\\", "");
    path = path.replace("\n", "");

    QString tmp_py_cammand = _py_cammand;
    tmp_py_cammand = tmp_py_cammand.replace("/", "");
    tmp_py_cammand = tmp_py_cammand.replace("\\", "");
    tmp_py_cammand = tmp_py_cammand.replace("\n", "");

    qDebug() << "tmp_py_cammand" << tmp_py_cammand;

    QStringList filter_strings = { tmp_py_cammand, "Microsoft Windows [", "Microsoft Corporation", path };
    QString out = QString::fromLocal8Bit(p_exe_python_script_process->readAllStandardOutput().toStdString().c_str());

    out.replace("\r\n", "nisodaisuki_sp");
    out.replace("\n", "nisodaisuki_sp");
    out.replace("/", "\\");

    QStringList ls = out.split("nisodaisuki_sp");



    //qDebug() << "out" << out;
    for (QString pre_sava_log : ls)
    {
        if (pre_sava_log == "")
        {
            continue;
        }
        QString tmp = pre_sava_log.replace("\\", "");
        bool is_contain = true;
        for (QString str : filter_strings)
        {
            QString tmp = pre_sava_log.replace("/", "");
            tmp = pre_sava_log.replace("\\", "");
            if (tmp.contains(str))
            {
                is_contain = false;
                break;
            }
        }
        if (is_contain )
        {
            qDebug() << "saved: " << pre_sava_log;
            llod.write_log(pre_sava_log+"\n");
        }
    }
}

/**
 * @brief 更新[执行python程序后结果列表]信号的槽函数
 * @param row       该条记录插入在列表表中的行数
 * @param result    python脚本执行的结果
 */
void MainWindow::slot_on_update_execute_python_script_result_table(PY_RESULT result)
{
    if ( (result.result == POCENV_CHECKED_EXIST))
    {
        // 更新 [结果表] 的显示
        int next_row_count = ui->tbw_result->rowCount();
        ui->tbw_result->insertRow(next_row_count);
        
        QLabel* lb = new QLabel;
        lb->setText(result.tag);
        lb->adjustSize();
        lb->setOpenExternalLinks(true);
        lb->setWordWrap(true);
        
        ui->tbw_result->setItem(next_row_count, 0, new QTableWidgetItem(result.host));
        ui->tbw_result->item(next_row_count, 0)->setTextAlignment(Qt::AlignCenter);
        //ui->tbw_result->setItem(next_row_count, 1, new QTableWidgetItem(result.tag));
        //ui->tbw_result->item(next_row_count, 1)->setTextAlignment(Qt::AlignCenter);
        //ui->tbw_result->setItem(next_row_count, 2, new QTableWidgetItem(result.result));
        ui->tbw_result->setCellWidget(next_row_count, 1, lb);
        
        ui->tbw_result->resizeRowToContents(next_row_count);

        // 添加到全局链表
        GShared::exec_python_script_result_list.push_back(result);
    }
    
    // 更新进度条
    // +1 是因为row是从0开始的，_scan_total_value的值为size，相差1.
    double v = (++_scan_current_value + 0.0) / _scan_total_value * 100;
    //_total_progressBar.setValue(v);
    ui->progressBar->setFormat(QString::fromLocal8Bit("%1%").arg(QString::number(v, 'f', 2)));
    ui->progressBar->setValue(v);
}

/**
 * @brief 显示POC的列表中的某一项被点击了
 * @param item  被点击的项
 */
void MainWindow::on_poc_lstw_itemClicked(QListWidgetItem *item)
{
    // 因为POC列表中的某一项被点击了，用户选择的POC链表就会改变。
    // 这里先清零再根据状态进行添加。
    GShared::filter_poc_selected_list.clear();
    
    // 点击了最上面的那一行，不是全选，就是全不选。
    if (0 == ui->poc_lstw->row(item))
    {
        // 全选POC链表
        if  (item->checkState() == Qt::CheckState::Checked)
        {
            // 把全局过滤的总链表 复制给 筛选
            GShared::filter_poc_selected_list = GShared::filter_poc_list;
            for (int i = 1; i < ui->poc_lstw->count(); i++)
            {
                // 更新界面 使所有项为 选择
                QListWidgetItem* idx_item = ui->poc_lstw->item(i);
                idx_item->setCheckState(Qt::CheckState::Checked);
            }
        }
        // 全不选POC链表
        else if  (item->checkState() == Qt::CheckState::Unchecked)
        {
            for (int i = 1; i < ui->poc_lstw->count(); i++)
            {
                // 更新界面 使所有项为 不选
                QListWidgetItem* idx_item = ui->poc_lstw->item(i);
                idx_item->setCheckState(Qt::CheckState::Unchecked);
            }
        }
    }
    // 修改对应项的状态，并且更新 已选POC链表。
    else
    {
        // 遍历列表中的每一项
        // 如果满足就加入链表。
        for (int i = 1; i < ui->poc_lstw->count(); i++)
        {
            QListWidgetItem* idx_item = ui->poc_lstw->item(i);
            if  (idx_item->checkState() == Qt::CheckState::Checked)
            {
                GShared::filter_poc_selected_list.push_back(GShared::filter_poc_list.at(i-1));
            }
        }

        // 如果每一项都选择了，将最上面的全选钩给勾上。
        if (GShared::filter_poc_selected_list.size() == GShared::filter_poc_list.size())
        {
            qDebug () << "filter_poc_selected_list == filter_poc_list" ;
            ui->poc_lstw->item(0)->setCheckState(Qt::CheckState::Checked);
        }
        // 否则，将最上面的全选钩就不勾。
        else
        {
            ui->poc_lstw->item(0)->setCheckState(Qt::CheckState::Unchecked);
        }
    }
}

/**
 * @brief 当用户点击了菜单栏中的按钮，会调用这个函数。
 * @param 用户点击哪一个
 */
void MainWindow::on_menu_list_itemClicked(QListWidgetItem *item)
{
    // 非用户模式，直接返回。
    if (!is_user_mode)
    {
        return;
    }

    // 确定用户点击了哪一个菜单按钮
    // 不是用户点击的按钮，就隐藏对应的窗口。
    // 是用户点击按钮，显示对应的窗口。
    switch (ui->menu_list->row(item))
    {
    case 0:
        ui->widget->show();
        _edit_ips_txt_window.hide();
        _cmd_window.hide();
        _setting_window.hide();
    break;
    case 1:
        ui->widget->hide();
        _edit_ips_txt_window.show();
        _cmd_window.hide();
        _setting_window.hide();
    break;
    case 2:
        ui->widget->hide();
        _edit_ips_txt_window.hide();
        _cmd_window.show();
        emit _cmd_window.signal_update_cursor_position();
        _setting_window.hide();
    break;
    case 3:
        ui->widget->hide();
        _edit_ips_txt_window.hide();
        _cmd_window.hide();
        _setting_window.show();
    break;
    }
}

/**
 * @brief 当用户点击了筛选组件中的 [直接输入] 单选按钮时，执行该函数。
 * 为了设置target_mode，知道用户选择哪一种方式来确定主机。
 */
void MainWindow::on_radio_input_string_clicked()
{
    _target_mode = 0;
}

/**
 * @brief 当用户点击了筛选组件中的 [从文本导入] 单选按钮时，执行该函数。
 * 为了设置target_mode，知道用户选择哪一种方式来确定主机。
 */
void MainWindow::on_radio_text_file_clicked()
{
    _target_mode = 1;
}

void MainWindow::on_exe_pyscript_thread_finished()
{
    // [检测] 按钮可用
    ui->btn_exe_poc->setEnabled(true);

    // [停止] 按钮不可用
    ui-> btn_exe_stop->setEnabled(false);
    // 开启现场执行权限
    _exe_python_script_thread_status = 0;
}


void MainWindow::on_btn_exe_stop_clicked()
{
    _exe_python_script_thread_status = 1;
}

void MainWindow::on_settingwindow_log_comboBox_changed(SETTINGWINDOW_COMBOBOX_LOG status)
{
    _setting.set_logsetting(status);
    qDebug() << "on_settingwindow_log_comboBox_changed   " << _setting.is_open_log();
}




void MainWindow::on_tbw_result_customContextMenuRequested(const QPoint &pos)
{
    _contextMenu_result_table.clear();

    _contextMenu_row = ui->tbw_result->rowAt(pos.y());
    _contextMenu_col =  ui->tbw_result->columnAt(pos.x());

    /*
        设置右键菜单
        [访问此地址]
        [漏洞利用]
    */
    QAction* pAct_visitWeb = _contextMenu_result_table.addAction(QSTR("访问此地址"));
    QAction* pAct_exeEXP = _contextMenu_result_table.addAction(QSTR("漏洞利用"));
    if (_contextMenu_row < 0)
    {
        pAct_visitWeb->setDisabled(true);
        pAct_exeEXP->setDisabled(true);
    }


    connect(pAct_visitWeb, SIGNAL(triggered()), this, SLOT(on_visit_web()));
    connect(pAct_exeEXP, SIGNAL(triggered()), this, SLOT(on_execute_exp()));
    _contextMenu_result_table.exec(QCursor::pos());
}

void MainWindow::on_visit_web()
{
    // 得到对应行的主机IP
    QTableWidgetItem *item = ui->tbw_result->item(_contextMenu_row, 0);
    QString host_ip = item->text();

    // 打开对应的主机IP
    if(QDesktopServices::openUrl(QUrl( "http://" + host_ip ))){}
    else if (QDesktopServices::openUrl(QUrl("https://" + host_ip ))){}
    else {QMessageBox::information(this, QSTR("提示"), QSTR("打开此地址失败."));}
}
