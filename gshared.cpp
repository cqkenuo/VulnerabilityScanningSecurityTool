#include "dialog_scanports.h"
#include "gshared.h"

QString GShared::program_path;

QString GShared::python2_path;
QString GShared::python3_path;
/////////////程序目录下//////////////////////
// 全局poc配置文件[gconfig.xml]
QString GShared::poc_xml_file;

// 程序目录下poc文件夹
QString GShared::program_poc_path;
// 程序目录下exp文件夹
QString GShared::program_exp_dir;
// ip列表文件
// 程序目录/ipslist
QString GShared::program_ipslist_file;

// config.json所在的路径
QString GShared::program_poc_lib_configjson_file;

// 程序目录下，innertools文件夹dd
QString GShared::program_tools;

// 程序目录下，logs文件夹
QString GShared::program_logs;
QString GShared::program_vulnInfo;

QString GShared::poc_list_widget_title = QString::fromLocal8Bit("漏洞列表");

QFont GShared::ubuntu_font;

//菜单栏图标的初始化
QIcon GShared::menu_icon_main_normal;
QIcon GShared::menu_icon_main_clicked;
QIcon GShared::menu_icon_editIP_normal;
QIcon GShared::menu_icon_editIP_clicked;
QIcon GShared::menu_icon_console_normal;
QIcon GShared::menu_icon_console_clicked;
QIcon GShared::menu_icon_setting_normal;
QIcon GShared::menu_icon_setting_clicked;

QStringList GShared::sys_filter_list;
QStringList GShared::app_filter_list;
QStringList GShared::cms_filter_list;
QList<POC> GShared::filter_poc_list;
QList<POC> GShared::filter_poc_selected_list;
QList<VULNERABILITY_INFO> GShared::filter_poc_exist_vulnerability;
THREAD_SCANPORT GShared::scan_port_thread;
QList<SCANPORTRESULT> GShared::scan_port_result_list;

QObject* GShared::_p_slotObj_dialogScanPorts = nullptr;

GShared::GShared()
{
}

void GShared::init_gshared()
{
    
    program_path = QDir::currentPath();
    python2_path = program_path + "/pythonInterpreter/python27/python2.exe";
    python3_path = program_path + "/pythonInterpreter/python37/python3.exe";

    poc_xml_file = program_path + "/gconfig.xml";
    program_poc_path = program_path + "/poc/";
    program_exp_dir = program_path + "/exp/";
    program_ipslist_file = program_path + "/" + Q_FILE_NAME_IPS_LIST_TXT;
    program_poc_lib_configjson_file = program_poc_path + "lib/config.json";

    program_tools = program_path + "/innertools/";

    program_logs = program_path + "/logs/";
    program_vulnInfo = program_path + "/vulnInfo/";


    //菜单栏图标的初始化
    menu_icon_main_normal = QIcon(GShared::program_path + "/src/" + MENU_ICON_MAIN_NORMAL);
    menu_icon_main_clicked = QIcon(GShared::program_path + "/src/" + MENU_ICON_MAIN_CLICKED);
    menu_icon_editIP_normal = QIcon(GShared::program_path + "/src/" + MENU_ICON_EDIT_IPS_TXT_NORMAL);
    menu_icon_editIP_clicked = QIcon(GShared::program_path + "/src/" + MENU_ICON_EDIT_IPS_TXT_CLICKED);
    menu_icon_console_normal = QIcon(GShared::program_path + "/src/" + MENU_ICON_CONSOLE_NORMAL);
    menu_icon_console_clicked = QIcon(GShared::program_path + "/src/" + MENU_ICON_CONSOLE_CLICKED);
    menu_icon_setting_normal = QIcon(GShared::program_path + "/src/" + MENU_ICON_SETTING_NORMAL);
    menu_icon_setting_clicked = QIcon(GShared::program_path + "/src/" + MENU_ICON_SETTING_CLICKED);

    QDir* dir = new QDir;
    if (!dir->exists(program_logs))
    {
        dir->mkdir(program_logs);
    }

    QString family = loadFontFamilyFromFiles("./src/nisof.ttf");
    ubuntu_font.setFamily(family);
    //ubuntu_font.setPointSize(12);
}

// 如果当前程序的路径大于150个字节返回false；
// 否则返回true。
// 用于检查程序所在的路径是否过深。
// 如果过深的话，就无法修改pip.exe中的python路径。
bool GShared::check_path_lenth(QWidget* widget)
{
    if (program_path.size() >= 130)
    {
        QMessageBox::information(widget, QString::fromLocal8Bit("too long"), QString::fromLocal8Bit("程序所在路径应小于150个字节p"));
        return false;
    }
    return true;
}

void GShared::modify_python2pipexe_file()
{
    long pip_exe_offset = 0x19002;
    QString pip_exe_path = program_path + "/pythonInterpreter/python27/Scripts/pip2.exe";
    
    //得到python2.exe的绝对路径，然后把这个路径写道pip2.exe中
    const char* p_p2_exe_path = python2_path.toStdString().c_str();

    FILE* pf_pipexe = fopen(pip_exe_path.toStdString().c_str(), "rb+");
    // 检查文件是否成功。
    if (pf_pipexe == nullptr)
    {
        return;
    }

    fseek(pf_pipexe, pip_exe_offset, SEEK_SET);
    fwrite(python2_path.toStdString().c_str(), strlen(p_p2_exe_path)+1, 1, pf_pipexe);
    fclose(pf_pipexe);
}

void GShared::modify_python3pipexe_file()
{
    long pip_exe_offset = 0x19002;
    QString pip_exe_path = program_path + "/pythonInterpreter/python37/Scripts/pip3.exe";

    //得到python3.exe的绝对路径，然后把这个路径写道pip3.exe中
    const char* p_p3_exe_path = python3_path.toStdString().c_str();

    FILE* pf_pipexe = fopen(pip_exe_path.toStdString().c_str(), "rb+");
    // 检查文件是否成功。
    if (pf_pipexe == nullptr)
    {
        return;
    }

    fseek(pf_pipexe, pip_exe_offset, SEEK_SET);
    fwrite(python3_path.toStdString().c_str(), strlen(p_p3_exe_path) + 1, 1, pf_pipexe);
    fclose(pf_pipexe);
}

QString GShared::get_datatime()
{
    QDateTime current_date_time = QDateTime::currentDateTime();
    return current_date_time.toString("MMddhhmmss");
}

QString GShared::loadFontFamilyFromFiles(const QString &fontFileName)
{
    static QHash<QString, QString> tmd;
    if (tmd.contains(fontFileName)) {
        return tmd.value(fontFileName);
    }
    QString font = "";
    QFile fontFile(fontFileName);
    qDebug() << "FONR FILE : " << fontFile.fileName();
    if(!fontFile.open(QIODevice::ReadOnly)) {
        qDebug()<<"Open font file error";
        return font;
    }

    int loadedFontID = QFontDatabase::addApplicationFontFromData(fontFile.readAll());
    QStringList loadedFontFamilies = QFontDatabase::applicationFontFamilies(loadedFontID);
    if(!loadedFontFamilies.empty()) {
        font = loadedFontFamilies.at(0);
    }
    fontFile.close();

    if (!(font.isEmpty()))
        tmd.insert(fontFileName, font);
    return font;
}

QString GShared::getHostIpAddress()
{

    QString strIpAddress;
        QList<QHostAddress> ipAddressesList = QNetworkInterface::allAddresses();
        // 获取第一个本主机的IPv4地址
        int nListSize = ipAddressesList.size();
        for (int i = 0; i < nListSize; ++i)
        {
               if (ipAddressesList.at(i) != QHostAddress::LocalHost &&
                   ipAddressesList.at(i).toIPv4Address()) {
                   strIpAddress = ipAddressesList.at(i).toString();
                   break;
               }
         }
         // 如果没有找到，则以本地IP地址为IP
         if (strIpAddress.isEmpty())
            strIpAddress = QHostAddress(QHostAddress::LocalHost).toString();
         return strIpAddress;
}

void GShared::start_scan_port_thread(const QObject* slot_obj = nullptr)
{
    // 准备开始真正的执行python脚本
    // 新建一个线程
    QThread* m_workerThread = new QThread();
    // 新建一个真正工作的线程
    

    if (slot_obj != nullptr && _p_slotObj_dialogScanPorts != slot_obj)
    {
        if (_p_slotObj_dialogScanPorts != nullptr)
        {
            QObject::disconnect(&scan_port_thread, SIGNAL(signal_hostScanFinished(QString)), slot_obj, SLOT(slot_readyReadHost(QString)));
        }
        QObject::connect(&scan_port_thread, SIGNAL(signal_hostScanFinished(QString)), slot_obj, SLOT(slot_readyReadHost(QString)));
        _p_slotObj_dialogScanPorts = (QObject*)slot_obj;
    }
    QObject::connect(m_workerThread, &QThread::started, &scan_port_thread, &THREAD_SCANPORT::start1);//on_exe_pyscript_thread_finished
    QObject::connect(m_workerThread, &QThread::finished, m_workerThread, &QThread::deleteLater);
    QObject::connect(&scan_port_thread, &THREAD_SCANPORT::workFinished, &scan_port_thread, &THREAD_SCANPORT::deleteLater);
    QObject::connect(&scan_port_thread, &THREAD_SCANPORT::workFinished, m_workerThread, &QThread::quit);

    scan_port_thread.moveToThread(m_workerThread);
    m_workerThread->start();
    
}

void GShared::get_json()
{
    QFile loadFile("C:\\Users\\nisodaisuki\\Documents\QTProject\\VulnerabilityScanningSecurityTool-plus\\poc\\config.json");

    if(!loadFile.open(QIODevice::ReadOnly))
    {
        qDebug() << "could't open projects json";
        return;
    }

    QByteArray allData = loadFile.readAll();
    loadFile.close();

    QJsonParseError json_error;
    QJsonDocument jsonDoc(QJsonDocument::fromJson(allData, &json_error));

    if(json_error.error != QJsonParseError::NoError)
    {
        qDebug() << "json error!";
        return;
    }

    QJsonObject rootObj = jsonDoc.object();

    QStringList keys = rootObj.keys();
    for(int i = 0; i < keys.size(); i++)
    {
        qDebug() << "key" << i << " is:" << keys.at(i);
    }

    //因为是预先定义好的JSON数据格式，所以这里可以这样读取
    if(rootObj.contains("first fruit") && rootObj["first fruit"].isObject())
    {
        QJsonObject subObj = rootObj["first fruit"].toObject();
        if (subObj.contains("describe") && subObj["describe"].isString())
        {
            qDebug() << "describe is:" << subObj["describe"].toString();
        }
        if (subObj.contains("icon") && subObj["icon"].isString())
        {
            qDebug() << "icon is:" << subObj["icon"].toString();
        }
        if (subObj.contains("name") && subObj["name"].isString())
        {
            qDebug() << "name is:" << subObj["name"].toString();
        }
    }

    if(rootObj.contains("second fruit") && rootObj["second fruit"].isObject())
    {
        QJsonObject subObj = rootObj["second fruit"].toObject();
        if (subObj.contains("describe") && subObj["describe"].isString())
        {
            qDebug() << "describe is:" << subObj["describe"].toString();
        }
        if (subObj.contains("icon") && subObj["icon"].isString())
        {
            qDebug() << "icon is:" << subObj["icon"].toString();
        }
        if (subObj.contains("name") && subObj["name"].isString())
        {
            qDebug() << "name is:" << subObj["name"].toString();
        }
    }

    if(rootObj.contains("three fruit array") && rootObj["three fruit array"].isArray())
    {
        QJsonArray subArray = rootObj.value("three fruit array").toArray();
        for(int i = 0; i< subArray.size(); i++)
        {
            if (subArray[i].isString())
            {
                qDebug() << i<<" value is:" << subArray.at(i).toString();
            }
        }
    }
}

QStringList GShared::formatIP(QString iptext, bool* result)
{
    bool rtn_formatResult = true;
    QStringList rtn_ips;
    /*
        用户在输入框中输入字符串共有3中规则。
        1. 单个IP         特征：无-(中划线)符号 IP段下拉框为 [未选择]
        2. 连续单IP       特征：有-(中划线)符号 IP段下拉框为 [未选择]
    */

    // 连续IP
    if (iptext.contains("-"))
    {
        QStringList strings = iptext.split("-");
        QString ip_start = strings[0];
        QString ip_end_number = strings[1];

        QStringList ip_segments = ip_start.split(".");
        if (ip_segments.size() != 4)
        {
            rtn_formatResult = false;
            goto FUNCTION_END;
        }

        int ipSegmens[5] = {0};
        //a.b.c.d-e
        //检测a.b.c.d的合法性
        bool isSuccess_str2Int = true;
        for (size_t i = 0; i < 4; i++)
        {
            bool result;
            ipSegmens[i] = ip_segments[i].toInt(&result);
            if (result == false || ipSegmens[i] <= 0 || ipSegmens[i] > 256)
            {
                rtn_formatResult = false;
                goto FUNCTION_END;
            }
        }
        //检测e的合法性
        {
            bool result;
            ipSegmens[4] = ip_end_number.toInt(&result);
            if (result == false || ipSegmens[4] <= 0 || ipSegmens[4] > 256)
            {
                rtn_formatResult = false;
                goto FUNCTION_END;
            }
        }


        // 此时我们认为 [输入合法]
        QString qstr_ip = QString::number(ipSegmens[0]) + "." + QString::number(ipSegmens[1]) + "." + QString::number(ipSegmens[2]) + ".";
        for (size_t i = ipSegmens[3]; i <= ipSegmens[4]; i++)
        {
            QString ip = qstr_ip + QString::number(i);
            rtn_ips.push_back(ip);
        }
    }

    // 单个IP
    else
    {
        QStringList ip_segments = iptext.split(".");
        if (ip_segments.size() != 4)
        {
            rtn_formatResult = false;
            goto FUNCTION_END;
        }

        bool isSuccess_str2Int = true;
        for (size_t i = 0; i < 4; i++)
        {
            bool result;
            int tmp = ip_segments[i].toInt(&result);
            if (result == false || tmp <= 0 || tmp > 256)
            {
                rtn_formatResult = false;
                goto FUNCTION_END;
            }
        }

        rtn_ips.push_back(iptext);
    }

FUNCTION_END:
    if (result != nullptr)
    {
        *result = rtn_formatResult;
    }
    return rtn_ips;
}

VulnDetailInfo GShared::parseVulnDetailInfo(QString xml_file)
{
    VulnDetailInfo vulnDetailInfo;
    // 打开或创建文件
    // 检验是否正常打开
    QFile file(xml_file);
    if (!file.open(QFile::ReadOnly))
    {
        // 打开文件失败。
        return vulnDetailInfo;
    }

    QDomDocument doc;
    if (!doc.setContent(&file))
    {
        file.close();
        return vulnDetailInfo;
    }
    file.close();


    // 开始正常解析
    // 返回根节点(niso)
    QDomElement root = doc.documentElement();

    // 根节点下的第一个标签(sys)
    QDomNode node = root.firstChild();
    //如果节点不空
    while (!node.isNull())
    {
        //如果节点是元素
        if (node.isElement())
        {
            //转换为元素，注意元素和节点是两个数据结构，其实差不多
            QDomElement note_CVE = node.toElement();
            // 遍历子元素，count和size都可以用,可用于标签数计数
            QDomNodeList list = note_CVE.childNodes();
            for (int i = 0; i < list.count(); i++)
            {
                switch (vulnDetailInfo.getIdxByString(list.at(i).nodeName()))
                {
                case XML_NODE_NAME://name
                    vulnDetailInfo.name = list.at(i).toElement().text();
                    break;
                case XML_NODE_TYPE:
                    vulnDetailInfo.type = list.at(i).toElement().text();
                    break;
                case XML_NODE_RANK:
                    vulnDetailInfo.rank = list.at(i).toElement().text();
                    break;
                case XML_NODE_TIME:
                    vulnDetailInfo.time = list.at(i).toElement().text();
                    break;
                case XML_NODE_EFFECT:
                    vulnDetailInfo.effect = list.at(i).toElement().text();
                    break;
                case XML_NODE_CATEGORY:
                    vulnDetailInfo.category = list.at(i).toElement().text();
                    break;
                case XML_NODE_CVE:
                    vulnDetailInfo.cve = list.at(i).toElement().text();
                    break;
                case XML_NODE_DORK:
                    vulnDetailInfo.dork = list.at(i).toElement().text();
                    break;
                case XML_NODE_CASE:
                    vulnDetailInfo.case_ = list.at(i).toElement().text();
                    break;
                case XML_NODE_REFER:
                    vulnDetailInfo.refer = list.at(i).toElement().text();
                    break;
                case XML_NODE_DESC:
                    vulnDetailInfo.desc = list.at(i).toElement().text();
                    break;
                case XML_NODE_VERIFY:
                    vulnDetailInfo.verify = list.at(i).toElement().text();
                    break;
                case XML_NODE_REPAIR:
                    vulnDetailInfo.repair = list.at(i).toElement().text();
                    break;
                case XML_NODE_PAYLOAD:
                    vulnDetailInfo.payload = list.at(i).toElement().text();
                    break;
                case XML_NODE_KEYWORD:
                    vulnDetailInfo.keyword = list.at(i).toElement().text();
                    break;
                }
            }
        }
        node = node.nextSibling();
    }
    return vulnDetailInfo;
}
