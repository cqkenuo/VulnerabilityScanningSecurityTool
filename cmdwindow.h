#ifndef CMDWINDOW_H
#define CMDWINDOW_H

#include <QKeyEvent>
#include <QProcess>
#include <QTextEdit>
#include <QTimer>
#include <QWidget>
#include "mytextedit.h"
namespace Ui {
class CMDWindow;
}

class CMDWindow : public QWidget
{
    Q_OBJECT

public:
    explicit CMDWindow(QWidget *parent = nullptr);
    ~CMDWindow();

    /*******************************************/
    // 当前光标的位置
    // 这个坐标用于判断编辑框是否能编辑
    int _cursor_line = 0;
    int _cursor_column = 0;
    int _content_string_current_idx = 0;

    // 自定义的编辑框，继承于QTextEdit
    MYTextEdit _my_text_edit;
    

    // 0 cmd
    // 1 nc
    int _cmd_type = 0;
    QTimer *timer = nullptr;
    int _running_process_id = 0;
    int _run_time = 3;
    QProcess _cmd_process;
    QProcess _nc_process;
    QString _last_cammand;


signals:
    /**
     * @brief signal_update_cursor_position
     */
    void signal_update_cursor_position();

    // 当命令执行结束发送信号
    void signal_execute_cammand_finished();
private slots:
    /**
     * @brief 当编辑框的光标位置发生改变时，调用这个槽函数。
     * 主要是为了判断当前位置能不能接受输入，以及能不能接受退格键
     */
    void on_cursorPositionChanged();

    /**
     * @brief 终端用标准信息时自动调用这个槽函数
     * 相应信号[readyReadStandardOutput]
     */
    void on_cmd_process_readoutput();

    /**
     * @brief 终端用错误信息时自动调用这个槽函数
     * 相应信号[readyReadStandardError]
     */
    void on_cmd_process_readerror();

    /**
     * @brief 当用户按下回车键，执行命令时，调用这个槽函数
     * 执行 终端 命令的单元
     */
    void on_exe_cammand();

    /**
     * @brief [signal_update_cursor_position]信号的槽函数
     * 菜单栏点击了[控制台]选项时，会调用这个函数，主要是为了[更新输入行和列]
     */
    void slot_on_update_cursor_position();

    void on_timeout();


private:
    Ui::CMDWindow *ui;

private:
    /**
     * @brief 更新成员属性[当前输入位置的行和列]
     * 将光标移到编辑框的最后，更新[_cursor_column]和[_cursor_line]
     */
    void update_cursor_position();

    /**
     * @brief 链接用到的信号与槽
     */
    void connect_signal_and_slot();

    void check();
};

#endif // CMDWINDOW_H
